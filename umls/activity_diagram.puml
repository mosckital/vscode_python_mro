@startuml client_lifecycle
start
: Load settings from workspace or user input;
: Construct ClientOptions;
: Construct ServerOptions;
: Embed the start of Language Server into the Server Options;
: Construct LanguageClient based on ClientOptions and ServerOptions;
: Push the constructed LanguageClient into <b>context.subscriptions</b>,
so that the client can be correctly disposed when no longer needed;
end
@enduml

@startuml server_lifecycle
start
partition onStartUp {
    :create a connection for the server;
    :create a text document manager;
    :register the listeners for
    the relevant state change
    events on the connection;
    note right
        the state change listeners may include:
        * onInitialize()
        * onInitialized()
        * onDidChangeConfiguration()
        * onDidClose()
        * onDidChangeContent()
        * onDidChangeWatchedFiles()
        * onCodeLens()
        * onCodeLensResolve()
        * onHover()
    end note
    :make the text document manager
    listening to the connection;
    :let the connection start listening;
}
while (wait for initialisation) is (not received)
endwhile (received)
partition onInitialize {
    :extract the settings from the received parameters;
    :construct the InitializeResult based on the settings;
    note right
        the result includes the supported
        language features (CodeLens and
        Hover in our case) and how the
        text document will be synced
    end note
    :initialise the //jedi wrapper//, the //C3 linearisation node//
    and the //calculation cache node//;
    :send the InitializeResult back to client;
}
partition onInitialized {
    :register listeners to some further state change events
    according to the extracted settings;
}
end
@enduml

@startuml c3_linearisation
start
if (the target class is in cache?) is (no) then
    :fetch direct parent classes
    by using the //jedi// wapper;
    while (a parent class has no C3 result?) is (yes)
        :calculate C3 linearisation for this parent class
        by recursively calling this process;
    endwhile (no)
    :compute the C3 linearisation of the targe class;
    :store the result in cache;
else (yes)
    :retrieve result from cache;
endif
:return result;
end
@enduml

@startuml codelens_service
start
if (is the received symbol a class?) is (yes) then
    :calculate the MRO list
    of the target class
    via C3 Linearisation|
    :construct results in CodeLens format;
else (no)
    :set result to null;
endif
:return results;
end
@enduml

@startuml hover_service
start
if (is the received symbol a class?) then (yes)
    :calculate the MRO list
    of the target class
    via C3 Linearisation|
    :construct results in Hover format;
else (no)
    if (is the received symbol an object?) then (yes)
        if (can resolve the class of the object?) then (yes)
            :calculate the MRO list
            of the resolved class
            via C3 Linearisation|
            :construct results in Hover format;
        else (no)
            :set result to null;
        endif
    else (no)
        :set result to null;
    endif
endif
:return results;
end
@enduml

@startuml hover_method_service
start
if (is the received symbol a method?) then (yes)
    if (is the method calling from a class?) then (yes)
        :calculate the MRO list
        of the calling class
        via C3 Linearisation|
        :construct results in Hover format;
    else (no)
        if (is the method calling from an object?) then (yes)
            if (can resolve the class of the object?) then (yes)
                :calculate the MRO list
                of the resolved class
                via C3 Linearisation|
                :construct results in Hover format;
            else (no)
                :set result to null;
            endif
        else (no)
            :set result to null;
        endif
    endif
else (no)
    :set result to null;
endif
:return results;
end
@enduml